/*
 *
 * Copyright (c) 2022-2024 Carbon Community
 * All rights reserved.
 *
 */

using System;
using System.IO;
using System.Linq;
using Carbon.Core;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Doorstop.Utility;

namespace Doorstop.Patches;
#pragma warning disable IDE0051

internal sealed class RustHarmony : MarshalByRefObject
{
	private static readonly DefaultAssemblyResolver _resolver;
	private readonly AssemblyDefinition _assembly;
	private readonly string _filename;

	static RustHarmony()
	{
		_resolver = new DefaultAssemblyResolver();
		_resolver.AddSearchDirectory(Defines.GetLibFolder());
		_resolver.AddSearchDirectory(Defines.GetManagedModulesFolder());
		_resolver.AddSearchDirectory(Defines.GetManagedFolder());
		_resolver.AddSearchDirectory(Defines.GetRustManagedFolder());
	}

	public RustHarmony()
	{
		_filename = Path.Combine(Defines.GetRustManagedFolder(), "Rust.Harmony.dll");

		if (!File.Exists(_filename))
			throw new Exception($"Assembly file '{_filename}' was not found");

		_assembly = AssemblyDefinition.ReadAssembly(_filename,
			parameters: new ReaderParameters { AssemblyResolver = _resolver });
	}

	internal void Patch()
	{
		try
		{
			//Nuke_them_all();
			Clean_HarmonyLoader_Methods();
			Clean_HarmonyLoader_HarmonyMod();
			Remove_Harmony_Reference();
		}
		catch (System.Exception ex)
		{
			Logger.Error(ex.Message);
			throw ex;
		}
	}

	private void Clean_HarmonyLoader_Methods()
	{
		TypeDefinition type = _assembly.MainModule.GetType("HarmonyLoader");
		string[] Items = { "LoadHarmonyMods", "TryLoadMod", "TryUnloadMod", "LoadAssembly", "UnloadMod" };

		foreach (string Item in Items)
		{
			try
			{
				Logger.Debug($" - Patching {type.Name}.{Item}");

				MethodDefinition method = type.Methods.First(x => x.Name == Item);
				ILProcessor processor = method.Body.GetILProcessor();

				method.Body.Variables.Clear();
				method.Body.Instructions.Clear();
				method.Body.ExceptionHandlers.Clear();

				switch (method.ReturnType.FullName)
				{
					case "System.Void":
						break;

					case "System.Boolean":
						processor.Append(processor.Create(OpCodes.Ldc_I4_0));
						break;

					default:
						processor.Append(processor.Create(OpCodes.Ldnull));
						break;
				}

				processor.Append(processor.Create(OpCodes.Ret));
			}
			catch (System.Exception e)
			{
				Logger.Debug($" - Patching failed: {e.Message}");
			}
		}
	}

	private void Clean_HarmonyLoader_HarmonyMod()
	{
		TypeDefinition parent = _assembly.MainModule.GetType("HarmonyLoader");
		TypeDefinition child = parent.NestedTypes.First(x => x.Name == "HarmonyMod");

		string[] Items = { "Harmony" };

		foreach (string Item in Items)
		{
			try
			{
				PropertyDefinition prop = child.Properties.FirstOrDefault(x => x.Name == Item);
				if (prop is null) return;

				Logger.Debug($" - Patching {prop}");

				child.Methods.Remove(prop.GetMethod);
				child.Methods.Remove(prop.SetMethod);
				child.Properties.Remove(prop);

				FieldDefinition backingField = child.Fields.First(x => x.Name == $"<{Item}>k__BackingField");
				child.Fields.Remove(backingField);
			}
			catch (System.Exception e)
			{
				Logger.Debug($" - Patching failed: {e.Message}");
			}
		}
	}

	private void Remove_Harmony_Reference()
	{
		try
		{
			AssemblyNameReference harmony =
				_assembly.MainModule.AssemblyReferences.FirstOrDefault(x => x.Name == "0Harmony");

			if (harmony is null) return;
			_assembly.MainModule.AssemblyReferences.Remove(harmony);
			Logger.Debug($" - Remove '0Harmony' reference");
		}
		catch (System.Exception e)
		{
			Logger.Debug($" - Remove reference failed: {e.Message}");
		}
	}

	internal void Write()
	{
		try
		{
			Logger.Debug(" - Validating changes in-memory");

			using MemoryStream memoryStream = new MemoryStream();
			_assembly.Write(memoryStream);
			memoryStream.Position = 0;
			_assembly.Dispose();

			Logger.Debug(" - Writing changes to disk");

			using FileStream outputStream = File.Open(_filename, FileMode.Create); //  + ".new.dll"
			memoryStream.CopyTo(outputStream);
		}
		catch (System.Exception ex)
		{
			Logger.Error(ex.Message);
			throw ex;
		}
	}
}
